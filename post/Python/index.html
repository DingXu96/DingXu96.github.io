<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Python 要点 | Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://DingXu96.github.io//favicon.ico?v=1585470099864">
<link rel="stylesheet" href="https://DingXu96.github.io//styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1 计算
1.1 数字
/返还float，//返还int，%计算余数，**乘方
在交互模式下，上一次打印出来的表达式被赋值给变量 _
复数使用后缀 j 或者 J 就可以表示虚数部分（例如 3+5j ）
1.2 字符串
可以使用单引号（'……..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://DingXu96.github.io/">
        <img src="https://DingXu96.github.io//images/avatar.png?v=1585470099864" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://DingXu96.github.io//atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">Python 要点</h2>
            <div class="post-date">2020-03-04</div>
            
            <div class="post-content" v-pre>
              <h1 id="1-计算">1 计算</h1>
<h2 id="11-数字">1.1 数字</h2>
<p><code>/</code>返还float，<code>//</code>返还int，<code>%</code>计算余数，<code>**</code>乘方</p>
<p>在交互模式下，上一次打印出来的表达式被赋值给变量 <code>_</code></p>
<p>复数使用后缀 <code>j</code> 或者 <code>J</code> 就可以表示虚数部分（例如 <code>3+5j</code> ）</p>
<h2 id="12-字符串">1.2 字符串</h2>
<p>可以使用单引号（<code>'……'</code>），双引号（<code>&quot;……&quot;</code>），<code>\</code>用于转义</p>
<p>不希望前置了 <code>\</code> 的字符转义成特殊字符，可以使用 <em>原始字符串</em> 方式，在引号前添加 <code>r</code></p>
<p>字符串字面值可以跨行连续输入。一种方式是用三重引号：<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code> 或 <code>'''...'''</code>。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 <code>\</code> 即可。</p>
<p>字符串可以用 <code>+</code> 进行连接（粘到一起），也可以用 <code>*</code> 进行重复</p>
<p><strong>字符串索引从 0 开始</strong>，负数索引从右边开始数</p>
<p>索引切片的开始总是被包括其中，<strong>结束不被包括</strong></p>
<p>内建函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#len"><code>len()</code></a> 返回一个字符串的长度</p>
<h2 id="13-列表">1.3 列表</h2>
<p>最常用的<em>列表</em> ，可以通过方括号括起、逗号分隔的一组值得到</p>
<p>在列表结尾添加新元素 <code>cubes.append()</code></p>
<p>可以嵌套列表</p>
<h1 id="2-逻辑语句">2 逻辑语句</h1>
<h2 id="21-if">2.1 if</h2>
<pre><code class="language-python">if x &lt; 0:
	x = 0
	print('Negative changed to zero')
elif x == 0:
	print('Zero')
else:
	print('More')
</code></pre>
<h2 id="22-for">2.2 for</h2>
<pre><code class="language-python">for w in words:
	print(w, len(w))
</code></pre>
<h2 id="23-range">2.3 range()</h2>
<pre><code class="language-python">range(5, 10)
	5, 6, 7, 8, 9

range(0, 10, 3)
	0, 3, 6, 9
</code></pre>
<p>以序列的索引来迭代：</p>
<pre><code class="language-python">a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
	print(i, a[i])
#然而，在大多数这类情况下，使用 enumerate() 函数比较方便
seasons = ['Spring', 'Summer', 'Fall', 'Winter']
list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
</code></pre>
<p><code>range()</code>为可迭代对象</p>
<h2 id="24-break和continue以及else还有pass">2.4 break和continue以及else还有pass</h2>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break"><code>break</code></a> 语句，用于跳出最近的 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a> 或 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while"><code>while</code></a> 循环</p>
<p>循环语句可能带有 <code>else</code> 子句；它会在循环耗尽了可迭代对象 (使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#for"><code>for</code></a>) 或循环条件变为假值 (使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#while"><code>while</code></a>) 时被执行，但不会在循环被 <a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#break"><code>break</code></a> 语句终止时被执行。</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#continue"><code>continue</code></a> 语句表示继续循环中的下一次迭代</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/simple_stmts.html#pass"><code>pass</code></a> 语句什么也不做。当语法上需要一个语句，但程序需要什么动作也不做时，可以使用它。</p>
<h2 id="25-定义函数">2.5 定义函数</h2>
<pre><code class="language-python">def fib(n):    # write Fibonacci series up to n
	&quot;&quot;&quot;Print a Fibonacci series up to n.&quot;&quot;&quot;
	a, b = 0, 1
	while a &lt; n:
		print(a, end=' ')
		a, b = b, a+b
	print()
</code></pre>
<p>默认值是在 <em>定义过程</em> 中在函数定义处计算的，所以</p>
<pre><code class="language-python">i = 5
def f(arg=i):
	print(arg)

i = 6
f()
5
</code></pre>
<p><strong>重要警告：</strong> 默认值只会执行一次。</p>
<p>当存在一个形式为 <code>**name</code> 的最后一个形参时，它会接收一个字典 (参见 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#typesmapping">映射类型 --- dict</a>)，其中包含除了与已有形参相对应的关键字参数以外的所有关键字参数。 这可以与一个形式为 <code>*name</code>，接收一个包含除了与已有形参列表以外的位置参数的 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-tuples">元组</a> 的形参 (将在下一小节介绍) 组合使用 (<code>*name</code> 必须出现在 <code>**name</code> 之前。)</p>
<p>注意打印时关键字参数的顺序保证与调用函数时提供它们的顺序是相匹配的</p>
<p>仅限位置参数放在<code>/</code>之前</p>
<p>仅限关键字参数放在<code>*</code>之后</p>
<pre><code class="language-python">def f(pos1, pos2, /, pos_or_kwd, *, kwd1, kwd2):
</code></pre>
<p>可以使用 <code>*</code>操作符来编写函数调用以便从列表或元组中解包参数</p>
<p>字典可使用 <code>**</code> 操作符 来提供关键字参数</p>
<pre><code class="language-python">list(range(3, 6))            # normal call with separate arguments
args = [3, 6]
list(range(*args))            # call with arguments unpacked from a list
</code></pre>
<p>Lambda表达式</p>
<p>可以用 <a href="https://docs.python.org/zh-cn/3/reference/expressions.html#lambda"><code>lambda</code></a> 关键字来创建一个小的匿名函数。这个函数返回两个参数的和： <code>lambda a, b: a+b</code></p>
<h1 id="3-数据结构">3 数据结构</h1>
<h2 id="31-列表对象方法">3.1 列表对象方法</h2>
<p><code>list.append(x)</code></p>
<p>在列表的末尾添加一个元素。相当于 <code>a[len(a):] = [x]</code> 。</p>
<p><code>list.extend(iterable)</code></p>
<p>使用可迭代对象中的所有元素来扩展列表。相当于 <code>a[len(a):] = iterable</code> 。</p>
<p><code>list.insert(i, x)</code></p>
<p>在给定的位置插入一个元素。第一个参数是要插入的元素的索引，所以 <code>a.insert(0, x)</code> 插入列表头部， <code>a.insert(len(a), x)</code> 等同于 <code>a.append(x)</code> 。</p>
<p><code>list.remove(x)</code></p>
<p>移除列表中第一个值为 <em>x</em> 的元素。如果没有这样的元素，则抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。</p>
<p><code>list.pop([i])</code></p>
<p>删除列表中给定位置的元素并返回它。如果没有给定位置，<code>a.pop()</code> 将会删除并返回列表中的最后一个元素。（ 方法签名中 <em>i</em> 两边的方括号表示这个参数是可选的，而不是要你输入方括号。你会在 Python 参考库中经常看到这种表示方法)。</p>
<p><code>list.clear()</code></p>
<p>删除列表中所有的元素。相当于 <code>del a[:]</code> 。</p>
<p><code>list.index(x[, start[, end]])</code></p>
<p>返回列表中第一个值为 <em>x</em> 的元素的从零开始的索引。如果没有这样的元素将会抛出 <a href="https://docs.python.org/zh-cn/3/library/exceptions.html#ValueError"><code>ValueError</code></a> 异常。可选参数 <em>start</em> 和 <em>end</em> 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 <em>start</em> 参数。</p>
<p><code>list.count(x)</code></p>
<p>返回元素 <em>x</em> 在列表中出现的次数。</p>
<p><code>list.sort(key=None, reverse=False)</code></p>
<p>对列表中的元素进行排序（参数可用于自定义排序，解释请参见 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted"><code>sorted()</code></a>）。</p>
<p><code>list.reverse()</code></p>
<p>反转列表中的元素。</p>
<p><code>list.copy()</code></p>
<p>返回列表的一个浅拷贝。相当于 <code>a[:]</code> 。</p>
<h2 id="32-列表使用">3.2 列表使用</h2>
<p>作为栈使用非常容易“后进后出”</p>
<p>作为队列使用很低效“先进先出”</p>
<p>若要实现一个队列， <a href="https://docs.python.org/zh-cn/3/library/collections.html#collections.deque"><code>collections.deque</code></a> 被设计用于快速地从两端操作。</p>
<h2 id="33-列表推导式">3.3 列表推导式</h2>
<pre><code class="language-python">squares = []
for x in range(10):
    squares.append(x**2)
squares
#等价于
squares = [x**2 for x in range(10)]
#或者
squares = list(map(lambda x: x**2, range(10)))
##第二个例子
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]
</code></pre>
<p>如果表达式是一个元组（例如上面的 <code>(x, y)</code>），那么就必须加上括号</p>
<p>列表推导式可以嵌套</p>
<h2 id="34-元组和序列">3.4 元组和序列</h2>
<p>元组在输出时总是被圆括号包围的，以便正确表示嵌套元组。输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。给元组中的一个单独的元素赋值是不允许的，当然你可以创建包含可变对象的元组，例如列表。</p>
<p>一个特殊的问题是构造包含0个或1个元素的元组：为了适应这种情况，语法有一些额外的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建（圆括号里只有一个值的话不够明确）。</p>
<h2 id="35-集合">3.5 集合</h2>
<p>花括号或 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#set"><code>set()</code></a> 函数可以用来创建集合。</p>
<p><strong>注意</strong>：要创建一个空集合你只能用 <code>set()</code> 而不能用 <code>{}</code>，因为后者是创建一个空字典。</p>
<p>类似于 <a href="https://docs.python.org/zh-cn/3/tutorial/datastructures.html#tut-listcomps">列表推导式</a>，集合也支持推导式形式</p>
<h2 id="36-字典">3.6 字典</h2>
<p>字典是一个 <em>键：值</em> 对的集合，键必须是唯一的</p>
<p>一对花括号可以创建一个空字典：<code>{}</code> ，或者在一对花括号中放一些逗号分隔的键值对</p>
<pre><code class="language-python">&gt;&gt;&gt; tel = {'jack': 4098, 'sape': 4139}
&gt;&gt;&gt; tel['guido'] = 4127
&gt;&gt;&gt; tel
{'jack': 4098, 'sape': 4139, 'guido': 4127}
&gt;&gt;&gt; tel['jack']
4098
&gt;&gt;&gt; del tel['sape']
&gt;&gt;&gt; tel['irv'] = 4127
&gt;&gt;&gt; tel
{'jack': 4098, 'guido': 4127, 'irv': 4127}
&gt;&gt;&gt; list(tel)
['jack', 'guido', 'irv']
&gt;&gt;&gt; sorted(tel)
['guido', 'irv', 'jack']
&gt;&gt;&gt; 'guido' in tel
True
&gt;&gt;&gt; 'jack' not in tel
False
</code></pre>
<p><a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#dict"><code>dict()</code></a> 构造函数可以直接从键值对序列里创建字典。</p>
<p>此外，字典推导式可以从任意的键值表达式中创建字典</p>
<p>当关键字是简单字符串时，有时直接通过关键字参数来指定键值对更方便</p>
<pre><code class="language-python">dict(sape=4139, guido=4127, jack=4098)
</code></pre>
<h2 id="37-类">3.7 类</h2>
<p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p>
<pre><code class="language-python">class ClassName:
   '类的帮助信息'   #类文档字符串
   class_suite  #类体

class Employee:
   '所有员工的基类'
   empCount = 0
 
   def __init__(self, name, salary):
      self.name = name
      self.salary = salary
      Employee.empCount += 1
   
   def displayCount(self):
     print &quot;Total Employee %d&quot; % Employee.empCount
 
   def displayEmployee(self):
      print &quot;Name : &quot;, self.name,  &quot;, Salary: &quot;, self.salary
 
print &quot;Employee.__doc__:&quot;, Employee.__doc__
print &quot;Employee.__name__:&quot;, Employee.__name__
print &quot;Employee.__module__:&quot;, Employee.__module__
print &quot;Employee.__bases__:&quot;, Employee.__bases__
print &quot;Employee.__dict__:&quot;, Employee.__dict__
</code></pre>
<h2 id="38-循环的技巧">3.8 循环的技巧</h2>
<p>当在字典中循环时，用 <code>items()</code> 方法可将关键字和对应的值同时取出</p>
<pre><code class="language-python">&gt;&gt;&gt; knights = {'gallahad': 'the pure', 'robin': 'the brave'}
&gt;&gt;&gt; for k, v in knights.items():
...     print(k, v)
...
gallahad the pure
robin the brave
</code></pre>
<p>当在序列中循环时，用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#enumerate"><code>enumerate()</code></a> 函数可以将索引位置和其对应的值同时取出</p>
<pre><code class="language-python">&gt;&gt;&gt; for i, v in enumerate(['tic', 'tac', 'toe']):
...     print(i, v)
...
0 tic
1 tac
2 toe
</code></pre>
<p>当同时在两个或更多序列中循环时，可以用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#zip"><code>zip()</code></a> 函数将其内元素一一匹配。</p>
<pre><code class="language-python">&gt;&gt;&gt; questions = ['name', 'quest', 'favorite color']
&gt;&gt;&gt; answers = ['lancelot', 'the holy grail', 'blue']
&gt;&gt;&gt; for q, a in zip(questions, answers):
...     print('What is your {0}?  It is {1}.'.format(q, a))
...
What is your name?  It is lancelot.
What is your quest?  It is the holy grail.
What is your favorite color?  It is blue.
</code></pre>
<p>当逆向循环一个序列时，先正向定位序列，然后调用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#reversed"><code>reversed()</code></a> 函数</p>
<pre><code class="language-python">&gt;&gt;&gt; for i in reversed(range(1, 10, 2)):
...     print(i)
...
9
7
5
3
1
</code></pre>
<p>如果要按某个指定顺序循环一个序列，可以用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#sorted"><code>sorted()</code></a> 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列</p>
<pre><code class="language-python">&gt;&gt;&gt; basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
&gt;&gt;&gt; for f in sorted(set(basket)):
...     print(f)
...
apple
banana
orange
pear
</code></pre>
<p>有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的</p>
<pre><code class="language-python">&gt;&gt;&gt; import math
&gt;&gt;&gt; raw_data = [56.2, float('NaN'), 51.7, 55.3, 52.5, float('NaN'), 47.8]
&gt;&gt;&gt; filtered_data = []
&gt;&gt;&gt; for value in raw_data:
...     if not math.isnan(value):
...         filtered_data.append(value)
...
&gt;&gt;&gt; filtered_data
[56.2, 51.7, 55.3, 52.5, 47.8]
</code></pre>
<h2 id="39-深入条件控制">3.9 深入条件控制</h2>
<p><code>while</code> 和 <code>if</code> 条件句中可以使用任意操作</p>
<p>比较操作符 <code>in</code> 和 <code>not in</code> 校验一个值是否在（或不在）一个序列里。操作符 <code>is</code> 和 <code>is not</code> 比较两个对象是不是同一个对象。所有比较操作符优先级相同且低于数值运算。</p>
<p>在<code>and</code>,<code>or</code>,<code>not</code>中<code>not</code> 优先级最高， <code>or</code> 优先级最低。</p>
<p>在表达式内部赋值必须显式地使用 <a href="https://docs.python.org/zh-cn/3/faq/design.html#why-can-t-i-use-an-assignment-in-an-expression">海象运算符</a> <code>:=</code> 来完成。</p>
<h1 id="4-模块">4 模块</h1>
<pre><code class="language-python">import fibo
fibo.fib
#下面的例子可以把名字从一个被调模块内直接导入到现模块的符号表里，fibo未被定义
from fibo import fib, fib2
#导入所有非以下划线开头的名称
from fibo import *
##
import fibo as fib
fib.fib
from fibo import fib as fibonacci
#模块搜索路径
import sys
sys.path
#路径修改
sys.path.append()
</code></pre>
<h2 id="41-dir">4.1 dir()</h2>
<p>内置函数 <a href="https://docs.python.org/zh-cn/3/library/functions.html#dir"><code>dir()</code></a> 用于查找模块定义的名称。 它返回一个排序过的字符串列表</p>
<p>如果没有参数，<a href="https://docs.python.org/zh-cn/3/library/functions.html#dir"><code>dir()</code></a> 会列出你当前定义的名称</p>
<p><strong>注意</strong>：它列出所有类型的名称：变量，模块，函数，等等</p>
<h2 id="42-包">4.2 包</h2>
<p>必须要有 <code>__init__.py</code> 文件才能让 Python 将包含该文件的目录当作包。</p>
<p>包的用户可以从包中导入单个模块，例如:</p>
<pre><code class="language-python">import sound.effects.echo
</code></pre>
<p>这会加载子模块 <code>sound.effects.echo</code> 。但引用它时必须使用它的全名。</p>
<pre><code class="language-python">sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<p>导入子模块的另一种方法是</p>
<pre><code class="language-python">from sound.effects import echo
</code></pre>
<p>这也会加载子模块 <code>echo</code> ，并使其在没有包前缀的情况下可用，因此可以按如下方式使用:</p>
<pre><code class="language-python">echo.echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<p>另一种形式是直接导入所需的函数或变量:</p>
<pre><code class="language-python">from sound.effects.echo import echofilter
</code></pre>
<p>同样，这也会加载子模块 <code>echo</code>，但这会使其函数 <code>echofilter()</code> 直接可用:</p>
<pre><code class="language-python">echofilter(input, output, delay=0.7, atten=4)
</code></pre>
<h1 id="5-输入输出">5 输入输出</h1>
<h2 id="51-输出格式">5.1 输出格式</h2>
<p>要使用 <a href="https://docs.python.org/zh-cn/3/tutorial/inputoutput.html#tut-f-strings">格式化字符串字面值</a> ，请在字符串的开始引号或三引号之前加上一个 <code>f</code> 或 <code>F</code> 。在此字符串中，你可以在 <code>{</code> 和 <code>}</code> 字符之间写可以引用的变量或字面值的 Python 表达式。</p>
<pre><code class="language-python">year = 2016
event = 'Referendum'
f'Results of the {year} {event}'
</code></pre>
<p>字符串的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法需要更多的手动操作。你仍将使用 <code>{</code> 和 <code>}</code> 来标记变量将被替换的位置，并且可以提供详细的格式化指令，但你还需要提供要格式化的信息。</p>
<pre><code class="language-python">yes_votes = 42_572_654
no_votes = 43_132_495
percentage = yes_votes / (yes_votes + no_votes)
'{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)
</code></pre>
<p>可以使用 <a href="https://docs.python.org/zh-cn/3/library/functions.html#repr"><code>repr()</code></a> or <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str"><code>str()</code></a> 函数将任何值转化为字符串。</p>
<p>##5.2 格式化字符串文字</p>
<p><a href="https://docs.python.org/zh-cn/3/reference/lexical_analysis.html#f-strings">格式化字符串字面值</a> （常简称为 f-字符串）能让你在字符串前加上 <code>f</code> 和 <code>F</code> 并将表达式写成 <code>{expression}</code> 来在字符串中包含 Python 表达式的值。</p>
<p>可选的格式说明符可以跟在表达式后面。这样可以更好地控制值的格式化方式。</p>
<pre><code class="language-python">print(f'The value of pi is approximately {math.pi:.3f}.')
#在 ':' 后传递一个整数可以让该字段成为最小字符宽度。这在使列对齐时很有用。
table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print(f'{name:10} ==&gt; {phone:10d})
#其他的修饰符可用于在格式化之前转化值。 '!a' 应用 ascii() ，'!s' 应用 str()，还有 '!r' 应用 repr()
animals = 'eels'
print(f'My hovercraft is full of {animals}.')
print(f'My hovercraft is full of {animals!r}.')
</code></pre>
<h2 id="53-字符串的format-方法">5.3 字符串的format() 方法</h2>
<p>花括号和其中的字符（称为格式字段）将替换为传递给 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的对象。花括号中的数字可用来表示传递给 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法的对象的位置。</p>
<pre><code class="language-python">&gt;&gt;&gt; print('{0} and {1}'.format('spam', 'eggs'))
spam and eggs
&gt;&gt;&gt; print('{1} and {0}'.format('spam', 'eggs'))
eggs and spam
</code></pre>
<p>如果在 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.format"><code>str.format()</code></a> 方法中使用关键字参数，则使用参数的名称引用它们的值。</p>
<pre><code class="language-python">&gt;&gt;&gt; print('This {food} is {adjective}.'.format(
...       food='spam', adjective='absolutely horrible'))
This spam is absolutely horrible.
#位置和关键字参数可以任意组合
&gt;&gt;&gt; print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',other='Georg'))
The story of Bill, Manfred, and Georg.
</code></pre>
<p>如果你有一个非常长的格式字符串，你不想把它拆开，那么你最好按名称而不是位置引用变量来进行格式化。这可以通过简单地传递字典和使用方括号 <code>'[]'</code> 访问键来完成</p>
<pre><code class="language-python">&gt;&gt;&gt; table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
&gt;&gt;&gt; print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '
...       'Dcab: {0[Dcab]:d}'.format(table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
#这也可以通过使用 '**' 符号将 table 作为关键字参数传递。
&gt;&gt;&gt; table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
&gt;&gt;&gt; print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: {Dcab:d}'.format(**table))
Jack: 4098; Sjoerd: 4127; Dcab: 8637678
</code></pre>
<p>手动格式化字符串</p>
<p>字符串对象的 <a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.rjust"><code>str.rjust()</code></a> 方法通过在左侧填充空格来对给定宽度的字段中的字符串进行右对齐，还有另外一个方法，<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html#str.zfill"><code>str.zfill()</code></a> ，它会在数字字符串的左边填充零。它能识别正负号。</p>
<p>旧的字符串格式化方法，使用<code>%</code></p>
<pre><code class="language-python">print('The value of pi is approximately %5.3f.' % math.pi)
</code></pre>
<h2 id="54-读写文件">5.4 读写文件</h2>
<p><a href="https://docs.python.org/zh-cn/3/library/functions.html#open"><code>open()</code></a> 返回一个 <a href="https://docs.python.org/zh-cn/3/glossary.html#term-file-object">file object</a>，最常用的有两个参数： <code>open(filename, mode)</code></p>
<p><em>mode</em> 可以是 <code>'r'</code> ，表示文件只能读取，<code>'w'</code> 表示只能写入（已存在的同名文件会被删除），还有 <code>'a'</code> 表示打开文件以追加内容；任何写入的数据会自动添加到文件的末尾。<code>'r+'</code> 表示打开文件进行读写。<em>mode</em> 参数是可选的；省略时默认为 <code>'r'</code>。</p>
<p>在处理文件对象时，最好使用 <a href="https://docs.python.org/zh-cn/3/reference/compound_stmts.html#with"><code>with</code></a> 关键字。 优点是当子句体结束后文件会正确关闭，即使在某个时刻引发了异常。</p>
<pre><code class="language-python">with open('workfile') as f:
    read_data = f.read()
# We can check that the file has been automatically closed.
f.closed
</code></pre>
<h2 id="55-文件对象方法">5.5 文件对象方法</h2>
<p>要读取文件内容，请调用 <code>f.read(size)</code></p>
<p><code>f.readline()</code> 从文件中读取一行，如果 <code>f.readline()</code> 返回一个空的字符串，则表示已经到达了文件末尾，而空行使用 <code>'\n'</code> 表示</p>
<p>如果你想以列表的形式读取文件中的所有行，你也可以使用 <code>list(f)</code> 或 <code>f.readlines()</code></p>
<p><code>f.write(string)</code> 会把 <em>string</em> 的内容写入到文件中，并返回写入的字符数。</p>
<h2 id="56-用json保存结构化数据">5.6 用json保存结构化数据</h2>
<pre><code class="language-python">#如果你有一个对象 x ，你可以用一行简单的代码来查看它的 JSON 字符串表示
import json
json.dumps([1, 'simple', 'list'])
#如果 f 是一个 text file 对象，我们可以这样做
json.dump(x, f)
#要再次解码对象，如果 f 是一个打开的以供阅读的 text file 对象
x = json.load(f)
</code></pre>
<h1 id="6-标准库">6 标准库</h1>
<h2 id="61-操作系统接口">6.1 操作系统接口</h2>
<p>os模块和shutil模块</p>
<pre><code class="language-python">os.getcwd()      # Return the current working directory
os.chdir('/server/accesslogs')   # Change current working directory
os.system('mkdir today')   # Run the command mkdir in the system shell
shutil.copyfile('data.db', 'archive.db')
shutil.move('/build/executables', 'installdir')
</code></pre>
<h2 id="62-文件通配符">6.2 文件通配符</h2>
<p>glob模块可以用来在目录中使用通配符搜索创建文件列表中的函数</p>
<pre><code class="language-python">import glob
glob.glob('*.py')
</code></pre>
<h2 id="63-错误输出和程序终止">6.3 错误输出和程序终止</h2>
<pre><code class="language-python">sys.stderr.write('Warning, log file not found starting a new one\n')
#终止脚本
sys.exit()
</code></pre>
<h2 id="64-字符串匹配正则表达式">6.4 字符串匹配（正则表达式）</h2>
<p><code>\d</code>匹配一个数字，<code>\w</code>匹配一个字母或者一个数字，<code>.</code>可以匹配任意字符</p>
<p><code>\b</code>匹配空字符串，但只在单词开始或结尾的位置</p>
<p><code>\s</code>匹配任何Unicode空白字符，包括 <code>[ \t\n\r\f\v]</code></p>
<p><code>\number</code> 匹配数字代表的组合 <code>re.match(r'(.+) (.) \1','the 2 the')</code></p>
<p><code>*</code>表示任意个字符（包括0个）， <code>+</code>表示至少一个字符， <code>?</code>表示0或1个字符， <code>{n}</code>表示n个字符， <code>{n,m}</code>表示n-m个字符</p>
<p><code>[]</code>表示范围，例如</p>
<ul>
<li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li>
<li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'Py3000'</code>等等；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li>
<li><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
</ul>
<p><code>[^]</code>表示取反，所有不在范围里的字符会被匹配。</p>
<p><code>A|B</code>表示匹配A或B。绝不贪婪。</p>
<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>
<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>
<p><code>*?,+?,??,{n,m}?</code> 以非贪婪的方式匹配，尽量少的字符被匹配。</p>
<p><strong>切分字符串</strong>，<code>re.split()</code></p>
<p><strong>分组</strong>，<code>m.group()</code></p>
<pre><code class="language-python">m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
m.group(0)
'010-12345'
m.group(1)
'010'
m.group(2)
'12345'
</code></pre>
<p><strong>查找</strong> <code>re.search</code>和 <code>re.match</code></p>
<p><code>re.search</code>扫描整个 <em>字符串</em> 找到匹配样式的第一个位置，并返回一个相应的 <a href="https://docs.python.org/zh-cn/3/library/re.html#match-objects">匹配对象</a>。如果没有匹配，就返回一个 <code>None</code></p>
<p><code>re.match</code>如果 <em>string</em> 开始的0或者多个字符匹配到了正则表达式样式，就返回一个相应的 <a href="https://docs.python.org/zh-cn/3/library/re.html#match-objects">匹配对象</a> 。</p>
<p><strong>替换</strong><code>re.sub(pattern, repl, string)</code></p>
<p>当只需要简单的功能时，首选字符串方法</p>
<pre><code class="language-python">'tea for too'.replace('too', 'two')
</code></pre>
<h2 id="65-数学">6.5 数学</h2>
<p><a href="https://docs.python.org/zh-cn/3/library/math.html#module-math"><code>math</code></a> 模块提供对浮点数学的底层C库函数的访问</p>
<p><a href="https://docs.python.org/zh-cn/3/library/random.html#module-random"><code>random</code></a> 模块提供了进行随机选择的工具</p>
<p><a href="https://docs.python.org/zh-cn/3/library/statistics.html#module-statistics"><code>statistics</code></a> 模块计算数值数据的基本统计属性（均值，中位数，方差等）</p>
<h2 id="66-其他">6.6 其他</h2>
<p><strong>时间</strong>  <a href="https://docs.python.org/zh-cn/3/library/datetime.html#module-datetime"><code>datetime</code></a> 模块提供了以简单和复杂的方式操作日期和时间的类。虽然支持日期和时间算法，但实现的重点是有效的成员提取以进行输出格式化和操作。该模块还支持可感知时区的对象。</p>
<pre><code class="language-python">from datetime import date
now = date.today()
now.strftime(&quot;%m-%d-%y. %d %b %Y is a %A on the %d day of %B.&quot;)
# dates support calendar arithmetic
birthday = date(1964, 7, 31)
age = now - birthday
age.days
</code></pre>
<p><strong>压缩</strong>  常见的数据存档和压缩格式由模块直接支持，包括：<a href="https://docs.python.org/zh-cn/3/library/zlib.html#module-zlib"><code>zlib</code></a>, <a href="https://docs.python.org/zh-cn/3/library/gzip.html#module-gzip"><code>gzip</code></a>, <a href="https://docs.python.org/zh-cn/3/library/bz2.html#module-bz2"><code>bz2</code></a>, <a href="https://docs.python.org/zh-cn/3/library/lzma.html#module-lzma"><code>lzma</code></a>, <a href="https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile"><code>zipfile</code></a> 和 <a href="https://docs.python.org/zh-cn/3/library/tarfile.html#module-tarfile"><code>tarfile</code></a>。</p>
<p><strong>性能测量</strong>  <code>time</code>，<code>timeit</code></p>
<p><strong>互联网访问</strong> <a href="https://docs.python.org/zh-cn/3/library/urllib.request.html#module-urllib.request"><code>urllib.request</code></a> 用于从URL检索数据</p>
<pre><code class="language-python">from urllib.request import urlopen
with urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl') as response:
    for line in response:
        line = line.decode('utf-8')  # Decoding the binary data to text.
        if 'EST' in line or 'EDT' in line:  # look for Eastern Time
            print(line)
</code></pre>
<h1 id="7-安装包">7 *安装包</h1>
<p>使用pip安装，升级，移除包，<code>pip</code> 有许多命令“search”、“install”、“uninstall”、“freeze”</p>
<p>可以通过指定包的名称来安装最新版本的包</p>
<pre><code class="language-python">pip install novas
</code></pre>
<p>还可以通过提供包名称后跟 <code>==</code> 和版本号来安装特定版本的包</p>
<pre><code class="language-python">pip install requests==2.6.0
</code></pre>
<p>升级包</p>
<pre><code class="language-python">pip install --upgrade requests
</code></pre>
<p><code>pip list</code> 将显示虚拟环境中安装的所有软件包</p>
<h1 id="8-常用包">8 常用包</h1>
<h2 id="81-numpy">8.1 NumPy</h2>
<h3 id="811-数组创建">8.1.1 数组创建</h3>
<pre><code class="language-python">import numpy as np
a = np.array([1, 2, 3])   # Create a rank 1 array
print(a.shape)            # Prints &quot;(3,)&quot;
a[0] = 5                  # Change an element of the array
b = np.array([[1,2,3],[4,5,6]])    # Create a rank 2 array
print(b.shape)  # Prints &quot;(2, 3)&quot;
#创建数组的函数
a = np.zeros((2,2))   # Create an array of all zeros
b = np.ones((1,2))    # Create an array of all ones
c = np.full((2,2), 7)  # Create a constant array
d = np.eye(2)         # Create a 2x2 identity matrix
e = np.random.random((2,2))  # Create an array filled with random values
f = np.empty((2,3))  # Create an array with random values
</code></pre>
<p>Numpy的索引切片与python列表类似</p>
<p>整数索引允许使用另一个数组中的数据构造任意数组</p>
<pre><code class="language-python">a = np.array([[1,2], [3, 4], [5, 6]])
# An example of integer array indexing.
# The returned array will have shape (3,) and
print(a[[0, 1, 2], [0, 1, 0]])  # Prints &quot;[1 4 5]&quot;
# The above example of integer array indexing is equivalent to this:
print(np.array([a[0, 0], a[1, 1], a[2, 0]]))  # Prints &quot;[1 4 5]&quot;
# When using integer array indexing, you can reuse the same
# element from the source array:
print(a[[0, 0], [1, 1]])  # Prints &quot;[2 2]&quot;
</code></pre>
<p><code>np.array.ndim</code> 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank。</p>
<p><code>np.array.shape</code> 数组的维度</p>
<p><code>np.array.size</code> 数组元素的总数</p>
<p><code>np.array.dtype</code> 描述数组中元素类型的对象</p>
<p><code>np.array.itemsize</code> 数组中每个元素的字节大小</p>
<p>为了创建数字组成的数组，NumPy提供了一个类似于<code>range</code>的函数，该函数返回数组而不是列表。</p>
<pre><code class="language-python">np.arange( 10, 30, 5 )
array([10, 15, 20, 25])
np.arange( 0, 2, 0.3 )                 # it accepts float arguments
array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])
</code></pre>
<p>通常最好使用<code>linspace</code>函数来接收我们想要的元素数量的函数，而不是步长（step）</p>
<pre><code class="language-python">np.linspace( 0, 2, 9 )                 # 9 numbers from 0 to 2
x = np.linspace( 0, 2*pi, 100 ) 
</code></pre>
<h3 id="812-基本操作">8.1.2 基本操作</h3>
<p>数组上的算术运算符会应用到 <em>元素</em> 级别。</p>
<p>与许多矩阵语言不同，乘积运算符<code>*</code>在NumPy数组中按元素进行运算。矩阵乘积可以使用<code>@</code>运算符（在python&gt; = 3.5中）或<code>dot</code>函数或方法执行</p>
<pre><code class="language-python">A * B                       # elementwise product
A @ B                       # matrix product
A.dot(B)                    # another matrix product
</code></pre>
<p>许多一元操作，例如计算数组中所有元素的总和，都是作为<code>ndarray</code>类的方法实现的</p>
<pre><code class="language-python">a.sum()
a.min()
a.max()
#默认情况下，这些操作适用于数组，就像它是一个数字列表一样，无论其形状如何。但是，通过指定axis 参数，您可以沿数组的指定轴应用操作
a.sum(axis=0)
a.cumsum(axis=1)
</code></pre>
<h3 id="813-索引切片迭代">8.1.3 索引，切片，迭代</h3>
<p>三个点（ <code>...</code> ）表示产生完整索引元组所需的冒号。例如，如果 <code>x</code> 是rank为的5数组（即，它具有5个轴），则：</p>
<ul>
<li><code>x[1,2,...]</code> 相当于 <code>x[1,2,:,:,:]</code>，</li>
<li><code>x[...,3]</code> 等效于 <code>x[:,:,:,:,3]</code></li>
<li><code>x[4,...,5,:]</code> 等效于 <code>x[4,:,:,5,:]</code>。</li>
</ul>
<p>对多维数组进行 <strong>迭代（Iterating）</strong> 是相对于第一个轴完成的</p>
<pre><code class="language-python">for row in b:
    print (row)
[0 1 2 3]
[10 11 12 13]
[20 21 22 23]
[30 31 32 33]
[40 41 42 43]
</code></pre>
<p>如果对数组中的每一个元素进行操作，使用 <code>flat</code> 属性</p>
<pre><code class="language-python">for element in b.flat:
     print(element)
</code></pre>
<h3 id="814-操控形状">8.1.4 操控形状</h3>
<p>可以使用各种命令更改数组的形状。请注意，以下三个命令都返回一个修改后的数组，但不会更改原始数组</p>
<pre><code class="language-python">a.ravel()  # returns the array, flattened
a.reshape(6,2)  # returns the array with a modified shape
a.T  # returns the array, transposed
a.resize(6,2) #改变原始数组
</code></pre>
<p>数组合并</p>
<pre><code class="language-python">np.vstack((a,b)) #列堆叠
np.hstack((a,b)) #行堆叠
np.column_stack((a,b)) #对应行堆叠
a = np.array([4.,2.])
b = np.array([3.,8.])
np.column_stack((a,b))     # returns a 2D array
array([[ 4., 3.],
       [ 2., 8.]])
np.concatenate((a,b),axis=1) #通用方案
</code></pre>
<p>数组拆分</p>
<pre><code class="language-python">np.hsplit(a,3)   # 竖线Split a into 3
np.hsplit(a,(3,4))   # Split a after the third and the fourth column
np.vsplit(a,3) #横线split
np.split(a,(2,3),axis=1)#根据维度切
</code></pre>
<h3 id="815-拷贝与视图">8.1.5 拷贝与视图</h3>
<p>完全不复制</p>
<p>简单分配不会复制数组对象或其数据。</p>
<pre><code class="language-python">b = a            # no new object is created
b is a           # a and b are two names for the same ndarray object
True
b.shape = 3,4    # changes the shape of a
</code></pre>
<p>浅拷贝</p>
<p>不同的数组对象可以共享相同的数据。该<code>view</code>方法创建一个查看相同数据的新数组对象。</p>
<pre><code class="language-python">&gt;&gt;&gt; c = a.view()
&gt;&gt;&gt; c is a
False
&gt;&gt;&gt; c.base is a                        # c is a view of the data owned by a
True
&gt;&gt;&gt; c.flags.owndata
False
&gt;&gt;&gt;
&gt;&gt;&gt; c.shape = 2,6                      # a's shape doesn't change
&gt;&gt;&gt; a.shape
(3, 4)
&gt;&gt;&gt; c[0,4] = 1234                      # a's data changes
&gt;&gt;&gt; a
array([[   0,    1,    2,    3],
       [1234,    5,    6,    7],
       [   8,    9,   10,   11]])
</code></pre>
<p>深拷贝</p>
<p>该<code>copy</code>方法生成数组及其数据的完整副本。</p>
<pre><code class="language-python">d = a.copy()                          # a new array object with new data is created
</code></pre>
<p>有时，如果不再需要原始数组，则应在切片后调用 <code>copy</code>。例如，假设a是一个巨大的中间结果，最终结果b只包含a的一小部分，那么在用切片构造b时应该做一个深拷贝。如果改为使用 <code>b = a[:100]</code>，则 <code>a</code> 由 <code>b</code> 引用，并且即使执行 <code>del a</code> 也会在内存中持久存在。</p>
<h3 id="816-常用函数和方法">8.1.6 常用函数和方法</h3>
<ul>
<li><strong>数组的创建（Array Creation）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.arange.html#numpy.arange">arange</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.array.html#numpy.array">array</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.copy.html#numpy.copy">copy</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty.html#numpy.empty">empty</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.empty_like.html#numpy.empty_like">empty_like</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.eye.html#numpy.eye">eye</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfile.html#numpy.fromfile">fromfile</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.fromfunction.html#numpy.fromfunction">fromfunction</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.identity.html#numpy.identity">identity</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linspace.html#numpy.linspace">linspace</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.logspace.html#numpy.logspace">logspace</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mgrid.html#numpy.mgrid">mgrid</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ogrid.html#numpy.ogrid">ogrid</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones.html#numpy.ones">ones</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ones_like.html#numpy.ones_like">ones_like</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros.html#numpy.zeros">zeros</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.zeros_like.html#numpy.zeros_like">zeros_like</a></li>
<li><strong>转换和变换（Conversions）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype">ndarray.astype</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_1d.html#numpy.atleast_1d">atleast_1d</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_2d.html#numpy.atleast_2d">atleast_2d</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.atleast_3d.html#numpy.atleast_3d">atleast_3d</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mat.html#numpy.mat">mat</a></li>
<li><strong>操纵术（Manipulations）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.array_split.html#numpy.array_split">array_split</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.column_stack.html#numpy.column_stack">column_stack</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.concatenate.html#numpy.concatenate">concatenate</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.diagonal.html#numpy.diagonal">diagonal</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dsplit.html#numpy.dsplit">dsplit</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dstack.html#numpy.dstack">dstack</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.hsplit.html#numpy.hsplit">hsplit</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.hstack.html#numpy.hstack">hstack</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.item.html#numpy.ndarray.item">ndarray.item</a>, <a href="https://www.numpy.org.cn/reference/constants.html#numpy.newaxis">newaxis</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ravel.html#numpy.ravel">ravel</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.repeat.html#numpy.repeat">repeat</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.reshape.html#numpy.reshape">reshape</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.resize.html#numpy.resize">resize</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.squeeze.html#numpy.squeeze">squeeze</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.swapaxes.html#numpy.swapaxes">swapaxes</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.take.html#numpy.take">take</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.transpose.html#numpy.transpose">transpose</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vsplit.html#numpy.vsplit">vsplit</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vstack.html#numpy.vstack">vstack</a></li>
<li><strong>询问（Questions）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.all.html#numpy.all">all</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.any.html#numpy.any">any</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.nonzero.html#numpy.nonzero">nonzero</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.where.html#numpy.where">where</a>,</li>
<li><strong>顺序（Ordering）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.argmax.html#numpy.argmax">argmax</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.argmin.html#numpy.argmin">argmin</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.argsort.html#numpy.argsort">argsort</a>, <a href="https://docs.python.org/dev/library/functions.html#max">max</a>, <a href="https://docs.python.org/dev/library/functions.html#min">min</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ptp.html#numpy.ptp">ptp</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.searchsorted.html#numpy.searchsorted">searchsorted</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.sort.html#numpy.sort">sort</a></li>
<li><strong>操作（Operations）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.choose.html#numpy.choose">choose</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.compress.html#numpy.compress">compress</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.cumprod.html#numpy.cumprod">cumprod</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.cumsum.html#numpy.cumsum">cumsum</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.inner.html#numpy.inner">inner</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill">ndarray.fill</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.imag.html#numpy.imag">imag</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.prod.html#numpy.prod">prod</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.put.html#numpy.put">put</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.putmask.html#numpy.putmask">putmask</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.real.html#numpy.real">real</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.sum.html#numpy.sum">sum</a></li>
<li><strong>基本统计（Basic Statistics）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.cov.html#numpy.cov">cov</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.mean.html#numpy.mean">mean</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.std.html#numpy.std">std</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.var.html#numpy.var">var</a></li>
<li><strong>基本线性代数（Basic Linear Algebra）</strong> - <a href="https://numpy.org/devdocs/reference/generated/numpy.cross.html#numpy.cross">cross</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.dot.html#numpy.dot">dot</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.outer.html#numpy.outer">outer</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.linalg.svd.html#numpy.linalg.svd">linalg.svd</a>, <a href="https://numpy.org/devdocs/reference/generated/numpy.vdot.html#numpy.vdot">vdot</a></li>
</ul>
<h2 id="82-pandas">8.2 Pandas</h2>
<h3 id="821-生成对象">8.2.1 生成对象</h3>
<p>生成Series</p>
<pre><code class="language-python">s = pd.Series([1, 3, 5, np.nan, 6, 8])
</code></pre>
<p>生成DataFrame</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(6, 4), index=dates, columns=list('ABCD'))
#用 Series 字典对象生成 DataFrame:
df2 = pd.DataFrame({'A': 1.,
                    'B': pd.Timestamp('20130102'),
                    'C': pd.Series(1, index=list(range(4)), dtype='float32'),
                    'D': np.array([3] * 4, dtype='int32'),
                    'E': pd.Categorical([&quot;test&quot;, &quot;train&quot;, &quot;test&quot;, &quot;train&quot;]),
                    'F': 'foo'})
#DataFrame 的列有不同数据类型
df2.dtypes
</code></pre>
<h3 id="822-查看数据">8.2.2 查看数据</h3>
<pre><code class="language-python">df.head() #头部数据
df.tail() #尾部数据
df.index #索引
df.columns #列名
df.to_numpy() #输出数据的NumPy对象
df.describe() #统计摘要
df.T #转置数据
df.sort_index(axis=1,ascending=False) #按轴排序
df.sort_values(by='B') #按值排序
df.loc[,'A':'B'] #根据行，列取数据，按名称取
df.at[,] #根据行，列取数据，按名称取标量
df.iloc[,1:2] #根据行，列取数据，按位置取
df.iat[,] #根据行，列取数据，按位置取标量
df.A == df['A'] #选择单列
df[1:2] #切片行
df[df.A &gt; 0] #用单列的值选择数据
df2[df2['E'].isin(['two', 'four'])] #用isin()筛选
#用索引自动对齐新增列的数据
df.at[dates[0], 'A'] = 0 #按标签赋值
df.iat[0, 1] = 0 #按位置赋值
df.loc[:, 'D'] = np.array([5] * len(df)) #按 NumPy 数组赋值
</code></pre>
<h3 id="823-缺失值">8.2.3 缺失值</h3>
<p>重建索引（reindex）可以更改、添加、删除指定轴的索引，并返回数据副本，即不更改原数据。</p>
<pre><code class="language-python">df1 = df.reindex(index=,columns=)
df1.reset_index() #重设index
df1.dropna(how='any') #删除所有含有缺失值的行
df1.fillna(value=) #填充缺失值
pd.isna(df1) // df1.isna() #判断是否缺失值
DataFrame.drop_duplicates(subset=None, keep='first', inplace=False) #去重
</code></pre>
<h3 id="824-运算">8.2.4 运算</h3>
<pre><code class="language-python">#Apply处理数据
df.apply(np.cumsum)
df.apply(lambda x:x.max()-x.min())
df.value_counts() #计数
df.str.lower() #转小写
</code></pre>
<h3 id="825-合并">8.2.5 合并</h3>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html#pandas.concat"><code>concat()</code></a> 用于连接 Pandas 对象</p>
<pre><code class="language-python">df = pd.DataFrame(np.random.randn(10, 4))
pieces = [df[:3], df[3:7], df[7:]]
pd.concat(pieces)
</code></pre>
<p><code>pd.merge()</code> SQL 风格的合并。</p>
<pre><code class="language-python">left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})
right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})
pd.merge(left, right, on='key')
</code></pre>
<p><code>pd.append()</code>为DataFrame 追加行。</p>
<pre><code class="language-python">df.append(s, ignore_index=True)
</code></pre>
<h3 id="826-分组">8.2.6 分组</h3>
<pre><code class="language-python">df = pd.DataFrame({'A': ['foo', 'bar', 'foo', 'bar',
                         'foo', 'bar', 'foo', 'foo'],
                   'B': ['one', 'one', 'two', 'three',
                         'two', 'two', 'one', 'three'],
                   'C': np.random.randn(8),
                   'D': np.random.randn(8)})
df.groupby('A').sum()
df.groupby(['A','B']).sum()
</code></pre>
<h3 id="827-重塑">8.2.7 重塑</h3>
<pre><code class="language-python">tuples = list(zip(*[['bar', 'bar', 'baz', 'baz',
                     'foo', 'foo', 'qux', 'qux'],
                    ['one', 'two', 'one', 'two',
                     'one', 'two', 'one', 'two']]))
index = pd.MultiIndex.from_tuples(tuples, name=['1st','2nd'])
df.DataFrame(np.random.randn(8,2),index=index,columns=['A','B'])
##压缩 stack()
df.stack()
##逆压缩 unstack()
df.unstack()
##数据透视表(Pivot Tables)
pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C'])

</code></pre>
<h3 id="828-时间序列">8.2.8 时间序列</h3>
<pre><code class="language-python">rng = pd.date_range('1/1/2012', periods=100, freq='S')
ts = pd.Series(np.random.randint(0,500,len(rng)),index=rng)
#时间差转化
ts.resample('5Min').sum()
</code></pre>
<h3 id="829-其他">8.2.9 其他</h3>
<p>类别型数据</p>
<pre><code class="language-python">df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)
#用有含义的名字重命名不同类型，调用 Series.cat.categories
df[&quot;grade&quot;].cat.categories = ['Very Good','Good','Very Bad']
df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;,
                                              &quot;good&quot;, &quot;very good&quot;])
df.groupby(&quot;grade&quot;).size()
</code></pre>
<p>可视化</p>
<pre><code class="language-python">ts = pd.Series(np.random.random(500),index=pd.date_range('1/1/2020',periods=500))
ts.cumsum().plot()
</code></pre>
<p>数据输出/输入</p>
<pre><code class="language-python">df.to_csv('.csv')
pd.read_csv('.csv')
df.to_excel('.xlsx',sheet_name='Sheet1')
pd.read_excel('.xlsx','Sheet1',index_col=None, na_values=['NA'])
</code></pre>

            </div>
            
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
